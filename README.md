# 30.1 Вьюсеты и дженерики

Проект представляет собой учебный API на Django с использованием Django REST Framework (DRF).

## Стек

- Python 3.x
- Django 4.x (или ваша версия)
- Django REST Framework
- PostgreSQL (в качестве базы данных)
- (Дополнительно) Pillow для обработки изображений

## Описание проекта

- Кастомная модель пользователя с авторизацией по email  
- Приложение `users` — кастомный пользователь с полями email, телефон, город и аватарка  
- Приложение `lms` (или `materials`) — модели `Course` и `Lesson`  
- Связь: один курс содержит множество уроков  
- CRUD для курсов реализован через ViewSet  
- CRUD для уроков реализован через generic-классы (ListCreate, RetrieveUpdateDestroy)  
- Тестирование API — при помощи Postman

# 30.2 Сериализаторы

## Задание 1  
### Добавление в сериализатор модели Course поля количества уроков

- В сериализаторе модели `Course` добавлено поле `number_of_lessons` с помощью `SerializerMethodField`.
- Реализован метод `get_number_of_lessons`, который возвращает количество связанных уроков курса.
- Пример реализации в `CourseSerializer`:

```
number_of_lessons = serializers.SerializerMethodField()

def get_number_of_lessons(self, instance):
return instance.lesson_set.count()
```

## Задание 2  
### Создание модели Платежи (Payments) в приложении users

- Создана модель `Payments` со следующими полями:
- `user` — внешняя связь (ForeignKey) на модель пользователя `User`
- `payment_date` — дата и время оплаты (`DateTimeField`)
- `paid_course` — внешняя связь на модель курса `Course`, может быть `null`
- `paid_lesson` — внешняя связь на модель урока `Lesson`, может быть `null`
- `payment_amount` — сумма оплаты (`PositiveIntegerField`)
- `payment_method` — способ оплаты (`CharField` с вариантами: наличные, перевод на счет)
- Выполнены миграции.
- Для наполнения данных использовалась кастомная management-команда, которая создает пользователей, курсы, уроки и платежи.

---

## Задание 3  
### Вывод количества уроков и подробной информации по урокам в сериализаторе Course

- Создан вложенный сериализатор `LessonSerializer` для модели `Lesson`.
- В `CourseSerializer` добавлены два поля:
- `lessons` — список сериализованных уроков (используется `LessonSerializer(many=True, read_only=True, source='lesson_set')`)
- `number_of_lessons` — количество уроков через `SerializerMethodField`
- В результате сериализатор одновременно возвращает и количество уроков, и их подробную информацию.

## Задание 4  
### Настройка фильтрации и сортировки для API списка платежей

- Создан контроллер `PaymentsListAPIView` на основе `generics.ListAPIView`.
- Подключены фильтрация и сортировка:
- `DjangoFilterBackend` для фильтрации по курсу, уроку и способу оплаты.
- `OrderingFilter` для сортировки по дате оплаты.
- В `filterset_fields` указаны поля:
- `paid_course`
- `paid_lesson`
- `payment_method`
- В `ordering_fields` добавлено:
- `payment_date`
- Сортировка по умолчанию — по дате оплаты по убыванию (`-payment_date`).
- Для работы подключен и настроен пакет `django-filter` в `settings.py`.

# 31 Права доступа в DRF

## CRUD для пользователей и регистрация
- Реализован полный CRUD для модели пользователя (User), включая:
- Создание (регистрация) новых пользователей.
- Редактирование и удаление профиля.
- Просмотр списка и деталей пользователей (по необходимости).
- Для регистрации реализован отдельный эндпоинт, доступный для неавторизованных пользователей.

## JWT-авторизация
- В проекте настроена авторизация с помощью JWT (JSON Web Tokens) через библиотеку djangorestframework-simplejwt.
- Все эндпоинты, кроме регистрации и логина, требуют наличия валидного токена авторизации.
- Эндпоинты для регистрации и получения токенов (/token/ и /token/refresh/) доступны без авторизации.
- Защита эндпоинтов
- Для всех вьюсетов и generic-вью применён класс пермишенов, обеспечивающий:
- Доступ только авторизованным пользователям.
- Запрет на доступ для неавторизованных, кроме регистрации и логина.
- Права доступа для курсов и уроков
- Пользователи, не входящие в группу модераторов:
- Могут просматривать, редактировать и удалять только свои курсы и уроки.\
- Пользователи из группы модераторов имеют расширенные права и могут управлять всеми объектами.

## Запуск проекта через Docker Compose
### Предварительные требования
+ Установленные Docker и Docker Compose
+ Файл .env с необходимыми переменными окружения

## Установка
1. Клонируйте репозиторий:```git clone https://github.com/Alexandr-Celestial/SPA-Web_application```
2. Создайте файл .env в корне проекта на основе примера .env.sample
3. Запустите проект командой: ```docker-compose up --build```
4. После запуска выполните миграции: ```docker-compose exec web python manage.py migrate```
5. После запуска веб-приложение будет доступно по адресу: http://localhost:8000

## Проверка работоспособности сервисов
1. Django-приложение (web) Откройте в браузере: http://127.0.0.0:8000/
2. Celery worker Проверьте логи Celery на выполнение задач:
```docker-compose logs -f celery```
3. PostgreSQL (db) Подключитесь к БД для проверки:
```docker-compose exec db psql -U your_db_user -d your_db_name```
4. Redis Проверьте подключение:
```docker-compose exec redis redis-cli ping```
Должен вернуться PONG

## Дополнительные команды:
Для просмотра запущенных контейнеров:
```docker-compose ps```

Для остановки сервисов и удаления контейнеров:
```docker-compose down```

## Документация
Доступна по адресу: /swagger/ и /redoc/